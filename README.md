### Problem and corresponding algorithms

1. [Tortoise and hare algorithm](https://github.com/sleepingcat4/niche-algo/blob/master/tortoise_hare.py) - 287. Find the Duplicate Number (LeetCode)

-> **reading material:** https://cp-algorithms.com/others/tortoise_and_hare.html

2. [Sliding window Algorithm + a freq counter](https://github.com/sleepingcat4/niche-algo/blob/master/sliding_window_freq.py) - 76 Minimum window substring (LeetCode)

It takes uses the traditional sliding window technique + a hash based frequency counter using the ```Counter``` module. ```inf``` means infinity. It uses two pointers to find out the window length where the valid characters are situated and then uses slice in return statement to get them back. 

-> **reading material:** https://medium.com/@anil.goyal0057/mastering-the-sliding-window-algorithm-with-practical-examples-in-java-67bc327469d3

3. [Invert Binary Tree](https://github.com/sleepingcat4/niche-algo/blob/master/invert_tree.py) - 226. Invert Binary Tree (LeetCode)

I used a BFS + queue combined algorithm to do the inversion. It's kinda neat and fun. 

-> **reading material:** https://en.wikipedia.org/wiki/Breadth-first_search 
